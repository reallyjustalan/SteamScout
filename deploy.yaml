name: Deploy to EC2

on:
  push:
    branches: [ main ]

env:
  REPO_URL: ${{ github.repositoryUrl }}
  BRANCH: ${{ github.ref_name }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Deploy to EC2
      env:
        PRIVATE_KEY: ${{ secrets.SSH_KEY }}
        HOST: ${{ secrets.SSH_ADDRESS }}
        USER: ${{ secrets.SSH_USER }}
      run: |
        echo "$PRIVATE_KEY" > github-ec2.pem && chmod 600 github-ec2.pem
        ssh -o StrictHostKeyChecking=no -i github-ec2.pem ${USER}@${HOST} '
        echo "Current directory: $(pwd)"
        echo "Listing home directory:"
        ls -la ~

        REPO_DIR="$HOME/steamscout"

            if [ -d "$REPO_DIR/.git" ]; then
              cd "$REPO_DIR"
              git pull origin "$BRANCH"
            else
              git clone "$REPO_URL" "$REPO_DIR"
              cd "$REPO_DIR"
            fi

            # Stop and remove existing containers (if running)
            if [ -f docker-compose.yml ] || [ -f docker-compose.yaml ]; then
              echo "Using Docker Compose"
              docker compose down || true
              docker compose build
              docker compose up -d
            else
              echo "Using single Dockerfile"
              docker stop steamscout || true
              docker rm steamscout || true
              docker build -t steamscout .
              docker run -d --name steamscout -p 80:80 steamscout
            fi
          EOF

What this does:

    Checks if you already have the repo (steamscout) and pulls latest, else clones it.

    If it finds a docker-compose.yml, it uses Docker Compose:

        docker compose down (stops/removes old containers)

        docker compose build (builds images from the Dockerfile)

        docker compose up -d (starts containers in the background)

    If no compose file, it builds/runs with plain Docker, mapping port 80 (change as needed).

Step 3: Customizing

    Exposing Ports: Change -p 80:80 to match your app’s port mapping.

    .env File: If your app needs environment variables, upload the .env file before running Docker, as discussed in previous messages.

    Container Names: Make sure the names don’t conflict with existing containers.

Step 4: Permissions

If you get a permission denied error, use sudo docker ...
Or, add your user to the docker group (sudo usermod -aG docker $USER and re-login).
Pro Tip:

If you’re using secrets or want to avoid SSH scripting hell, you can also use the appleboy/ssh-action action for even cleaner syntax!
Let me know if:

    You want to upload the .env as well (I’ll add a step)

    Your app exposes a different port (I’ll edit the mapping)

    You want to use a Docker image from a registry, not build from Dockerfile

Just ask and I’ll adapt this to your exact needs!
You said:
instead of hardcoding the git repo, can I just use a inside variable? 
ChatGPT said:

Yes, you absolutely can!
Instead of hardcoding the git repo URL in your SSH command, you can pass it as an environment variable from GitHub Actions, or even better—use the information from the workflow context.

Here’s how you can do it:
Option 1: Pass as Environment Variable in the Workflow

Add it to your step’s env:

      env:
        PRIVATE_KEY: ${{ secrets.SSH_KEY }}
        HOST: ${{ secrets.SSH_ADDRESS }}
        USER: ${{ secrets.SSH_USER }}
        REPO_URL: ${{ github.repositoryUrl }}
        BRANCH: ${{ github.ref_name }}

    ${{ github.repositoryUrl }} is automatically set to your repository’s clone URL (e.g., https://github.com/reallyjustalan/SteamScout.git).

    ${{ github.ref_name }} gives you the branch name (e.g., main).

Then, inside your SSH script, reference those variables using $REPO_URL and $BRANCH.
Full Example with Dynamic Variables

name: Deploy to EC2

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Deploy to EC2
        env:
          PRIVATE_KEY: ${{ secrets.SSH_KEY }}
          HOST: ${{ secrets.SSH_ADDRESS }}
          USER: ${{ secrets.SSH_USER }}
          REPO_URL: ${{ github.repositoryUrl }}
          BRANCH: ${{ github.ref_name }}
        run: |
          echo "$PRIVATE_KEY" > github-ec2.pem
          chmod 600 github-ec2.pem

          ssh -o StrictHostKeyChecking=no -i github-ec2.pem ${USER}@${HOST} 'bash -s' <<'EOF'
            set -e

            REPO_DIR="$HOME/steamscout"

            if [ -d "$REPO_DIR/.git" ]; then
              cd "$REPO_DIR"
              git pull origin "$BRANCH"
            else
              git clone "$REPO_URL" "$REPO_DIR"
              cd "$REPO_DIR"
            fi

            if [ -f docker-compose.yml ] || [ -f docker-compose.yaml ]; then
              docker compose down || true
              docker compose build
              docker compose up -d
            else
              docker stop steamscout || true
              docker rm steamscout || true
              docker build -t steamscout .
              docker run -d --name steamscout -p 80:80 steamscout
            fi
          EOF

Let me know if you want to support additional use cases or need a quick test script!



